// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/geniusrabbit/blaze-api/server/graphql/models"
	"github.com/geniusrabbit/blaze-api/server/graphql/types"
)

type AdFormat struct {
	// Ad format ID
	ID uint64 `json:"ID"`
	// Codename of the ad format
	Codename string `json:"codename"`
	// Ad format type
	Type string `json:"type"`
	// Ad format title
	Title string `json:"title"`
	// Ad format description
	Description string `json:"description"`
	// Active status of the ad format
	Active models.ActiveStatus `json:"active"`
	// Width of the ad format
	Width int `json:"width"`
	// Height of the ad format
	Height int `json:"height"`
	// Minimum width of the ad format
	MinWidth int `json:"minWidth"`
	// Minimum height of the ad format
	MinHeight int `json:"minHeight"`
	// Configurations of the ad format which includes structure of assets and their properties
	Config    types.NullableJSON `json:"config"`
	CreatedAt time.Time          `json:"createdAt"`
	UpdatedAt time.Time          `json:"updatedAt"`
	DeletedAt *time.Time         `json:"deletedAt,omitempty"`
}

type AdFormatEdge struct {
	// A cursor for use in pagination
	Cursor string `json:"cursor"`
	// The AdFormat at the end of the edge
	Node *AdFormat `json:"node"`
}

// Input for querying ad formats
type AdFormatInput struct {
	// Codename of the ad format
	Codename *string `json:"codename,omitempty"`
	// Ad format type
	Type *string `json:"type,omitempty"`
	// Ad format title
	Title *string `json:"title,omitempty"`
	// Ad format description
	Description *string `json:"description,omitempty"`
	// Active status of the ad format
	Active *models.ActiveStatus `json:"active,omitempty"`
	// Width of the ad format
	Width *int `json:"width,omitempty"`
	// Height of the ad format
	Height *int `json:"height,omitempty"`
	// Minimum width of the ad format
	MinWidth *int `json:"minWidth,omitempty"`
	// Minimum height of the ad format
	MinHeight *int `json:"minHeight,omitempty"`
	// Configurations of the ad format which includes structure of assets and their properties
	Config *types.JSON `json:"config,omitempty"`
}

type AdFormatListFilter struct {
	ID       []uint64              `json:"ID,omitempty"`
	Codename []string              `json:"codename,omitempty"`
	Type     []string              `json:"type,omitempty"`
	Title    []string              `json:"title,omitempty"`
	Active   []models.ActiveStatus `json:"active,omitempty"`
}

type AdFormatListOrder struct {
	ID        *models.Ordering `json:"ID,omitempty"`
	Codename  *models.Ordering `json:"codename,omitempty"`
	Type      *models.Ordering `json:"type,omitempty"`
	Title     *models.Ordering `json:"title,omitempty"`
	Active    *models.Ordering `json:"active,omitempty"`
	CreatedAt *models.Ordering `json:"createdAt,omitempty"`
	UpdatedAt *models.Ordering `json:"updatedAt,omitempty"`
}

type AdFormatPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// The AdFormat that was created by this mutation.
	FormatID uint64 `json:"formatID"`
	// The AdFormat object accessible by a client.
	Format *AdFormat `json:"format"`
}

// Application object represents a site or mobile/desktop application.
type Application struct {
	ID          uint64 `json:"ID"`
	AccountID   uint64 `json:"accountID"`
	CreatorID   uint64 `json:"creatorID"`
	Title       string `json:"title"`
	Description string `json:"description"`
	// Unique application identifier, e.g., site domain or app bundle
	URI      string          `json:"URI"`
	Type     ApplicationType `json:"type"`
	Platform PlatformType    `json:"platform"`
	Premium  bool            `json:"premium"`
	// Status of the application
	Status models.ApproveStatus `json:"status"`
	// Active status of the application
	Active models.ActiveStatus `json:"active"`
	// Private status of the application
	Private PrivateStatus `json:"private"`
	// Categories associated with the application
	Categories []int `json:"categories,omitempty"`
	// Revenue share percentage with the publisher
	RevenueShare *float64 `json:"revenueShare,omitempty"`
	// Time marks
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt time.Time  `json:"updatedAt"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
}

// ApplicationEdge wrapper to access Application objects
type ApplicationEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The Application at the end of ApplicationEdge.
	Node *Application `json:"node"`
}

type ApplicationInput struct {
	// Account ID associated with the application and can be defined if have permission
	AccountID   *uint64 `json:"accountID,omitempty"`
	Title       *string `json:"title,omitempty"`
	Description *string `json:"description,omitempty"`
	// Unique application identifier, e.g., site domain or app bundle
	URI          *string               `json:"URI,omitempty"`
	Type         *ApplicationType      `json:"type,omitempty"`
	Platform     *PlatformType         `json:"platform,omitempty"`
	Premium      *bool                 `json:"premium,omitempty"`
	Status       *models.ApproveStatus `json:"status,omitempty"`
	Active       *models.ActiveStatus  `json:"active,omitempty"`
	Private      *PrivateStatus        `json:"private,omitempty"`
	Categories   []int                 `json:"categories,omitempty"`
	RevenueShare *float64              `json:"revenueShare,omitempty"`
}

type ApplicationListFilter struct {
	ID        []uint64              `json:"ID,omitempty"`
	Title     *string               `json:"title,omitempty"`
	URI       *string               `json:"URI,omitempty"`
	AccountID *uint64               `json:"accountID,omitempty"`
	Type      []ApplicationType     `json:"type,omitempty"`
	Platform  []PlatformType        `json:"platform,omitempty"`
	Premium   *bool                 `json:"premium,omitempty"`
	Status    *models.ApproveStatus `json:"status,omitempty"`
	Active    *models.ActiveStatus  `json:"active,omitempty"`
	Private   *PrivateStatus        `json:"private,omitempty"`
}

type ApplicationListOrder struct {
	ID        *models.Ordering `json:"ID,omitempty"`
	Title     *models.Ordering `json:"title,omitempty"`
	URI       *models.Ordering `json:"URI,omitempty"`
	Type      *models.Ordering `json:"type,omitempty"`
	Platform  *models.Ordering `json:"platform,omitempty"`
	Premium   *models.Ordering `json:"premium,omitempty"`
	Status    *models.Ordering `json:"status,omitempty"`
	Active    *models.Ordering `json:"active,omitempty"`
	CreatedAt *models.Ordering `json:"createdAt,omitempty"`
	UpdatedAt *models.Ordering `json:"updatedAt,omitempty"`
	DeletedAt *models.Ordering `json:"deletedAt,omitempty"`
}

// ApplicationPayload wrapper to access Application operation results
type ApplicationPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// The Application that was created or updated by this mutation.
	ApplicationID uint64 `json:"applicationID"`
	// The Application object accessible by a client.
	Application *Application `json:"application"`
}

// Browser model schema
type Browser struct {
	// Browser ID
	ID uint64 `json:"ID"`
	// Name of the browser
	Name string `json:"name"`
	// Description of the browser
	Description string `json:"description"`
	// Match expression for the browser
	MatchExp string `json:"matchExp"`
	// Active status of the browser
	Active models.ActiveStatus `json:"active"`
	// List of browser versions
	Versions []*BrowserVersion `json:"versions,omitempty"`
	// Creation time of the browser
	CreatedAt time.Time `json:"createdAt"`
	// Last update time of the browser
	UpdatedAt time.Time `json:"updatedAt"`
	// Deletion time of the browser
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
}

type BrowserEdge struct {
	// A cursor for use in pagination
	Cursor string `json:"cursor"`
	// The Browser at the end of the edge
	Node *Browser `json:"node"`
}

// Input for querying browsers
type BrowserInput struct {
	// Name of the browser
	Name *string `json:"name,omitempty"`
	// Description of the browser
	Description *string `json:"description,omitempty"`
	// Match expression for the browser
	MatchExp *string `json:"matchExp,omitempty"`
	// Active status of the browser
	Active *models.ActiveStatus `json:"active,omitempty"`
	// List of browser versions
	Versions []*BrowserVersionInput `json:"versions,omitempty"`
}

type BrowserListFilter struct {
	ID     []uint64              `json:"ID,omitempty"`
	Name   []string              `json:"name,omitempty"`
	Active []models.ActiveStatus `json:"active,omitempty"`
}

type BrowserListOrder struct {
	ID        *models.Ordering `json:"ID,omitempty"`
	Name      *models.Ordering `json:"name,omitempty"`
	Active    *models.Ordering `json:"active,omitempty"`
	CreatedAt *models.Ordering `json:"createdAt,omitempty"`
	UpdatedAt *models.Ordering `json:"updatedAt,omitempty"`
}

type BrowserPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// The Browser that was created by this mutation.
	BrowserID uint64 `json:"browserID"`
	// The Browser object accessible by a client.
	Browser *Browser `json:"browser"`
}

// BrowserVersion model schema
type BrowserVersion struct {
	// Minimum version
	Min string `json:"min"`
	// Maximum version
	Max string `json:"max"`
	// Name of the version
	Name string `json:"name"`
}

// Input for browser versions
type BrowserVersionInput struct {
	// Minimum version
	Min *string `json:"min,omitempty"`
	// Maximum version
	Max *string `json:"max,omitempty"`
	// Name of the version
	Name *string `json:"name,omitempty"`
}

// Advertising category schema
type Category struct {
	// Category ID
	ID uint64 `json:"ID"`
	// Name of the category
	Name string `json:"name"`
	// Description of the category
	Description string `json:"description"`
	// IAB category code of OpenRTB
	IABCode string `json:"IABCode"`
	// Parent category ID
	ParentID *uint64 `json:"parentID,omitempty"`
	// Parent category object
	Parent *Category `json:"parent,omitempty"`
	// Position of the category
	Position int `json:"position"`
	// Active status of the category
	Active models.ActiveStatus `json:"active"`
	// Creation time of the category
	CreatedAt time.Time `json:"createdAt"`
	// Last update time of the category
	UpdatedAt time.Time `json:"updatedAt"`
	// Deletion time of the category
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
}

type CategoryEdge struct {
	// A cursor for use in pagination
	Cursor string `json:"cursor"`
	// The Category at the end of the edge
	Node *Category `json:"node"`
}

// Input for querying categories
type CategoryInput struct {
	// Name of the category
	Name *string `json:"name,omitempty"`
	// Description of the category
	Description *string `json:"description,omitempty"`
	// IAB category code of OpenRTB
	IABCode *string `json:"IABCode,omitempty"`
	// Parent category ID
	ParentID *uint64 `json:"parentID,omitempty"`
	// Position of the category
	Position *int `json:"position,omitempty"`
	// Active status of the category
	Active *models.ActiveStatus `json:"active,omitempty"`
}

type CategoryListFilter struct {
	ID       []uint64              `json:"ID,omitempty"`
	Name     []string              `json:"name,omitempty"`
	IABCode  []string              `json:"IABCode,omitempty"`
	ParentID []uint64              `json:"parentID,omitempty"`
	Active   []models.ActiveStatus `json:"active,omitempty"`
}

type CategoryListOrder struct {
	ID        *models.Ordering `json:"ID,omitempty"`
	Name      *models.Ordering `json:"name,omitempty"`
	IABCode   *models.Ordering `json:"IABCode,omitempty"`
	ParentID  *models.Ordering `json:"parentID,omitempty"`
	Position  *models.Ordering `json:"position,omitempty"`
	Active    *models.Ordering `json:"active,omitempty"`
	CreatedAt *models.Ordering `json:"createdAt,omitempty"`
	UpdatedAt *models.Ordering `json:"updatedAt,omitempty"`
}

type CategoryPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// The Category that was created by this mutation.
	CategoryID uint64 `json:"categoryID"`
	// The Category object accessible by a client.
	Category *Category `json:"category"`
}

type Continent struct {
	// Continent ID
	ID uint64 `json:"ID"`
	// Continent code2
	Code2 string `json:"code2"`
	// Continent name
	Name string `json:"name"`
	// List of countries
	Countries []*Country `json:"countries,omitempty"`
}

type Coordinates struct {
	Lat float64 `json:"lat"`
	Lon float64 `json:"lon"`
}

type Country struct {
	// Country ID
	ID uint64 `json:"ID"`
	// Country code2
	Code2 string `json:"code2"`
	// Country code3
	Code3 string `json:"code3"`
	// Country name
	Name string `json:"name"`
	// Country native name
	NativeName string `json:"nativeName"`
	// Continent code
	ContinentCode string `json:"continentCode"`
	// Continent object
	Continent *Continent `json:"continent"`
	// Name of the capital city
	Capital string `json:"capital"`
	// Languages spoken in the country
	Languages []string `json:"languages,omitempty"`
	// Phone codes for the country
	PhoneCodes []string `json:"phoneCodes,omitempty"`
	// Time zones for the country
	TimeZones []*TimeZone `json:"timeZones,omitempty"`
	// Coordinates of the country
	Coordinates *Coordinates `json:"coordinates"`
	// List of currencies
	Currency []string `json:"currency,omitempty"`
}

// Device maker schema
type DeviceMaker struct {
	// Device maker ID
	ID uint64 `json:"ID"`
	// Name of the device maker
	Name string `json:"name"`
	// Description of the device type
	Description string `json:"description"`
	// Expression to match the device maker
	MatchExp string `json:"matchExp"`
	// List of device types
	Types []*DeviceType `json:"types,omitempty"`
	// List of device models
	Models []*DeviceModel `json:"models,omitempty"`
	// Active status of the device maker
	Active models.ActiveStatus `json:"active"`
	// Creation time of the device maker
	CreatedAt time.Time `json:"createdAt"`
	// Last update time of the device maker
	UpdatedAt time.Time `json:"updatedAt"`
	// Deletion time of the device maker
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
}

type DeviceMakerEdge struct {
	// A cursor for use in pagination
	Cursor string `json:"cursor"`
	// The DeviceMaker at the end of the edge
	Node *DeviceMaker `json:"node"`
}

// Input for querying device makers
type DeviceMakerInput struct {
	// Name of the device maker
	Name *string `json:"name,omitempty"`
	// Description of the device maker
	Description *string `json:"description,omitempty"`
	// Expression to match the device maker
	MatchExp *string `json:"matchExp,omitempty"`
	// Active status of the device maker
	Active *models.ActiveStatus `json:"active,omitempty"`
}

type DeviceMakerListFilter struct {
	ID     []uint64              `json:"ID,omitempty"`
	Name   []string              `json:"name,omitempty"`
	Active []models.ActiveStatus `json:"active,omitempty"`
}

type DeviceMakerListOrder struct {
	ID        *models.Ordering `json:"ID,omitempty"`
	Name      *models.Ordering `json:"name,omitempty"`
	Active    *models.Ordering `json:"active,omitempty"`
	CreatedAt *models.Ordering `json:"createdAt,omitempty"`
	UpdatedAt *models.Ordering `json:"updatedAt,omitempty"`
}

type DeviceMakerPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// The DeviceMaker that was created by this mutation.
	MakerID uint64 `json:"makerID"`
	// The DeviceMaker object accessible by a client.
	Maker *DeviceMaker `json:"maker"`
}

// Device model schema
type DeviceModel struct {
	// Device model ID
	ID uint64 `json:"ID"`
	// Name of the device model
	Name string `json:"name"`
	// Description of the device type
	Description string `json:"description"`
	// Expression to match the device model
	MatchExp string `json:"matchExp"`
	// Device type ID
	TypeID uint64 `json:"typeID"`
	// Device type object
	Type *DeviceType `json:"type,omitempty"`
	// Device maker ID
	MakerID uint64 `json:"makerID"`
	// Device maker object
	Maker *DeviceMaker `json:"maker,omitempty"`
	// List of device model versions
	Versions []*DeviceModelVersion `json:"versions,omitempty"`
	// Active status of the device model
	Active models.ActiveStatus `json:"active"`
	// Creation time of the device model
	CreatedAt time.Time `json:"createdAt"`
	// Last update time of the device model
	UpdatedAt time.Time `json:"updatedAt"`
	// Deletion time of the device model
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
}

type DeviceModelEdge struct {
	// A cursor for use in pagination
	Cursor string `json:"cursor"`
	// The DeviceModel at the end of the edge
	Node *DeviceModel `json:"node"`
}

// Input for querying device models
type DeviceModelInput struct {
	// Name of the device model
	Name *string `json:"name,omitempty"`
	// Description of the device model
	Description *string `json:"description,omitempty"`
	// Expression to match the device model
	MatchExp *string `json:"matchExp,omitempty"`
	// Device type ID
	TypeID *uint64 `json:"typeID,omitempty"`
	// Device maker ID
	MakerID *uint64 `json:"makerID,omitempty"`
	// Active status of the device model
	Active *models.ActiveStatus `json:"active,omitempty"`
	// List of device model versions
	Versions []*DeviceModelVersionInput `json:"versions,omitempty"`
}

type DeviceModelListFilter struct {
	ID      []uint64              `json:"ID,omitempty"`
	Name    []string              `json:"name,omitempty"`
	TypeID  []uint64              `json:"typeID,omitempty"`
	MakerID []uint64              `json:"makerID,omitempty"`
	Active  []models.ActiveStatus `json:"active,omitempty"`
}

type DeviceModelListOrder struct {
	ID        *models.Ordering `json:"ID,omitempty"`
	Name      *models.Ordering `json:"name,omitempty"`
	TypeID    *models.Ordering `json:"typeID,omitempty"`
	MakerID   *models.Ordering `json:"makerID,omitempty"`
	Active    *models.Ordering `json:"active,omitempty"`
	CreatedAt *models.Ordering `json:"createdAt,omitempty"`
	UpdatedAt *models.Ordering `json:"updatedAt,omitempty"`
}

type DeviceModelPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// The DeviceModel that was created by this mutation.
	ModelID uint64 `json:"modelID"`
	// The DeviceModel object accessible by a client.
	Model *DeviceModel `json:"model"`
}

// DeviceModelVersion model schema
type DeviceModelVersion struct {
	// Minimum version
	Min string `json:"min"`
	// Maximum version
	Max string `json:"max"`
	// Name of the version
	Name string `json:"name"`
}

type DeviceModelVersionInput struct {
	// Minimum version
	Min *string `json:"min,omitempty"`
	// Maximum version
	Max *string `json:"max,omitempty"`
	// Name of the version
	Name *string `json:"name,omitempty"`
}

// Device type schema
type DeviceType struct {
	// Device type ID
	ID uint64 `json:"ID"`
	// Name of the device type
	Name string `json:"name"`
	// Description of the device type
	Description string `json:"description"`
	// List of device models
	Models []*DeviceModel `json:"models,omitempty"`
	// Active status of the device type
	Active models.ActiveStatus `json:"active"`
}

// OS model schema
type Os struct {
	// OS ID
	ID uint64 `json:"ID"`
	// Name of the OS
	Name string `json:"name"`
	// Description of the OS
	Description string `json:"description"`
	// Expression to match the OS
	MatchExp string `json:"matchExp"`
	// Active status of the OS
	Active models.ActiveStatus `json:"active"`
	// List of OS versions
	Versions []*OSVersion `json:"versions,omitempty"`
	// Creation time of the OS
	CreatedAt time.Time `json:"createdAt"`
	// Last update time of the OS
	UpdatedAt time.Time `json:"updatedAt"`
	// Deletion time of the OS
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
}

type OSEdge struct {
	// A cursor for use in pagination
	Cursor string `json:"cursor"`
	// The OS at the end of the edge
	Node *Os `json:"node"`
}

// Input for querying OS
type OSInput struct {
	// Name of the OS
	Name *string `json:"name,omitempty"`
	// Description of the OS
	Description *string `json:"description,omitempty"`
	// Expression to match the OS
	MatchExp *string `json:"matchExp,omitempty"`
	// Active status of the OS
	Active *models.ActiveStatus `json:"active,omitempty"`
	// List of OS versions
	Versions []*OSVersionInput `json:"versions,omitempty"`
}

type OSListFilter struct {
	ID         []uint64              `json:"ID,omitempty"`
	Name       []string              `json:"name,omitempty"`
	Active     []models.ActiveStatus `json:"active,omitempty"`
	MinVersion *string               `json:"minVersion,omitempty"`
	MaxVersion *string               `json:"maxVersion,omitempty"`
}

type OSListOrder struct {
	ID        *models.Ordering `json:"ID,omitempty"`
	Name      *models.Ordering `json:"name,omitempty"`
	Active    *models.Ordering `json:"active,omitempty"`
	CreatedAt *models.Ordering `json:"createdAt,omitempty"`
	UpdatedAt *models.Ordering `json:"updatedAt,omitempty"`
}

type OSPayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// The OS that was created by this mutation.
	Osid uint64 `json:"OSID"`
	// The OS object accessible by a client.
	Os *Os `json:"OS"`
}

// OSVersion model schema
type OSVersion struct {
	// Minimum version
	Min string `json:"min"`
	// Maximum version
	Max string `json:"max"`
	// Name of the version
	Name string `json:"name"`
}

// Input for OS versions
type OSVersionInput struct {
	// Minimum version
	Min *string `json:"min,omitempty"`
	// Maximum version
	Max *string `json:"max,omitempty"`
	// Name of the version
	Name *string `json:"name,omitempty"`
}

// RTBSource object represents a source of RTB advertising
type RTBSource struct {
	ID          uint64 `json:"ID"`
	AccountID   uint64 `json:"accountID"`
	Title       string `json:"title"`
	Description string `json:"description"`
	// Status of source approval
	Status models.ApproveStatus `json:"status"`
	// Active status of source
	Active models.ActiveStatus `json:"active"`
	// Flags of source
	Flags         types.NullableJSON `json:"flags"`
	Protocol      string             `json:"protocol"`
	MinimalWeight float64            `json:"minimalWeight"`
	// After approval URL can't be changed
	URL                   string               `json:"URL"`
	Method                string               `json:"method"`
	RequestType           RTBRequestFormatType `json:"requestType"`
	Headers               types.NullableJSON   `json:"headers"`
	Rps                   int                  `json:"RPS"`
	Timeout               int                  `json:"timeout"`
	Accuracy              float64              `json:"accuracy"`
	PriceCorrectionReduce float64              `json:"priceCorrectionReduce"`
	AuctionType           AuctionType          `json:"auctionType"`
	MinBid                float64              `json:"minBid"`
	MaxBid                float64              `json:"maxBid"`
	Formats               []string             `json:"formats,omitempty"`
	DeviceTypes           []int64              `json:"deviceTypes,omitempty"`
	Devices               []int64              `json:"devices,omitempty"`
	Os                    []int64              `json:"OS,omitempty"`
	Browsers              []int64              `json:"browsers,omitempty"`
	Carriers              []int64              `json:"carriers,omitempty"`
	Categories            []int64              `json:"categories,omitempty"`
	Countries             []string             `json:"countries,omitempty"`
	Languages             []string             `json:"languages,omitempty"`
	Applications          []int64              `json:"applications,omitempty"`
	Domains               []string             `json:"domains,omitempty"`
	Zones                 []int64              `json:"zones,omitempty"`
	Secure                AnyOnlyExclude       `json:"secure"`
	AdBlock               AnyOnlyExclude       `json:"adBlock"`
	PrivateBrowsing       AnyOnlyExclude       `json:"privateBrowsing"`
	IP                    AnyIPv4IPv6          `json:"IP"`
	Config                types.NullableJSON   `json:"config"`
	CreatedAt             time.Time            `json:"createdAt"`
	UpdatedAt             time.Time            `json:"updatedAt"`
	DeletedAt             *time.Time           `json:"deletedAt,omitempty"`
}

// RTBSourceEdge wrapper to access of RTBSource objects
type RTBSourceEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The RTBSource at the end of RTBSourceEdge.
	Node *RTBSource `json:"node"`
}

type RTBSourceInput struct {
	AccountID   *uint64 `json:"accountID,omitempty"`
	Title       *string `json:"title,omitempty"`
	Description *string `json:"description,omitempty"`
	// Flags of source
	Flags         *types.NullableJSON `json:"flags,omitempty"`
	Protocol      *string             `json:"protocol,omitempty"`
	MinimalWeight *float64            `json:"minimalWeight,omitempty"`
	// After approval URL can't be changed
	URL                   *string               `json:"URL,omitempty"`
	Method                *string               `json:"method,omitempty"`
	RequestType           *RTBRequestFormatType `json:"requestType,omitempty"`
	Headers               *types.NullableJSON   `json:"headers,omitempty"`
	Rps                   *int                  `json:"RPS,omitempty"`
	Timeout               *int                  `json:"timeout,omitempty"`
	Accuracy              *float64              `json:"accuracy,omitempty"`
	PriceCorrectionReduce *float64              `json:"priceCorrectionReduce,omitempty"`
	AuctionType           *AuctionType          `json:"auctionType,omitempty"`
	MinBid                *float64              `json:"minBid,omitempty"`
	MaxBid                *float64              `json:"maxBid,omitempty"`
	Formats               []string              `json:"formats,omitempty"`
	DeviceTypes           []int64               `json:"deviceTypes,omitempty"`
	Devices               []int64               `json:"devices,omitempty"`
	Os                    []int64               `json:"OS,omitempty"`
	Browsers              []int64               `json:"browsers,omitempty"`
	Carriers              []int64               `json:"carriers,omitempty"`
	Categories            []int64               `json:"categories,omitempty"`
	Countries             []string              `json:"countries,omitempty"`
	Languages             []string              `json:"languages,omitempty"`
	Applications          []int64               `json:"applications,omitempty"`
	Domains               []string              `json:"domains,omitempty"`
	Zones                 []int64               `json:"zones,omitempty"`
	Secure                *AnyOnlyExclude       `json:"secure,omitempty"`
	AdBlock               *AnyOnlyExclude       `json:"adBlock,omitempty"`
	PrivateBrowsing       *AnyOnlyExclude       `json:"privateBrowsing,omitempty"`
	IP                    *AnyIPv4IPv6          `json:"IP,omitempty"`
	Config                *types.NullableJSON   `json:"config,omitempty"`
}

type RTBSourceListFilter struct {
	ID        []uint64 `json:"ID,omitempty"`
	AccountID *uint64  `json:"accountID,omitempty"`
}

type RTBSourceListOrder struct {
	ID        *models.Ordering `json:"ID,omitempty"`
	AccountID *models.Ordering `json:"accountID,omitempty"`
	Title     *models.Ordering `json:"title,omitempty"`
	CreatedAt *models.Ordering `json:"createdAt,omitempty"`
	UpdatedAt *models.Ordering `json:"updatedAt,omitempty"`
	DeletedAt *models.Ordering `json:"deletedAt,omitempty"`
}

// RTBSourcePayload wrapper to access of RTBSource oprtation results
type RTBSourcePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// The RTBSource that was created by this mutation.
	SourceID uint64 `json:"sourceID"`
	// The RTBSource object accessible by a client.
	Source *RTBSource `json:"source"`
}

type StatisticAdItem struct {
	Keys        []*StatisticItemKey `json:"keys,omitempty"`
	Spent       float64             `json:"spent"`
	Profit      float64             `json:"profit"`
	BidPrice    float64             `json:"bidPrice"`
	Requests    uint64              `json:"requests"`
	Impressions uint64              `json:"impressions"`
	Views       uint64              `json:"views"`
	Directs     uint64              `json:"directs"`
	Clicks      uint64              `json:"clicks"`
	Leads       uint64              `json:"leads"`
	Bids        uint64              `json:"bids"`
	Wins        uint64              `json:"wins"`
	Skips       uint64              `json:"skips"`
	Nobids      uint64              `json:"nobids"`
	Errors      uint64              `json:"errors"`
	Ctr         float64             `json:"CTR"`
	ECpm        float64             `json:"eCPM"`
	ECpc        float64             `json:"eCPC"`
	ECpa        float64             `json:"eCPA"`
}

// StatisticAdItemConnection is a paginated list of StatisticAdItem objects.
type StatisticAdItemConnection struct {
	// Total count of StatisticAdItem objects.
	TotalCount int                    `json:"totalCount"`
	Edges      []*StatisticAdItemEdge `json:"edges"`
	// List of StatisticAdItem objects.
	List []*StatisticAdItem `json:"list,omitempty"`
	// Information to aid in pagination.
	PageInfo *models.PageInfo `json:"pageInfo"`
}

type StatisticAdItemEdge struct {
	Next string           `json:"next"`
	Node *StatisticAdItem `json:"node"`
}

type StatisticAdKeyCondition struct {
	Key   StatisticKey       `json:"key"`
	Op    StatisticCondition `json:"op"`
	Value []any              `json:"value"`
}

type StatisticAdKeyOrder struct {
	Key   StatisticOrderingKey `json:"key"`
	Order models.Ordering      `json:"order"`
}

type StatisticAdListFilter struct {
	Conditions []*StatisticAdKeyCondition `json:"conditions,omitempty"`
	StartDate  *types.DateTime            `json:"startDate,omitempty"`
	EndDate    *types.DateTime            `json:"endDate,omitempty"`
}

type StatisticItemKey struct {
	Key   StatisticKey `json:"key"`
	Value any          `json:"value"`
	Text  string       `json:"text"`
}

type TimeZone struct {
	Name string  `json:"name"`
	Lon  float64 `json:"lon"`
}

// Zone object represents a specific advertising zone within an account.
type Zone struct {
	ID          uint64   `json:"ID"`
	Codename    string   `json:"codename"`
	AccountID   uint64   `json:"accountID"`
	Title       string   `json:"title"`
	Description string   `json:"description"`
	Type        ZoneType `json:"type"`
	// Status of the zone
	Status models.ApproveStatus `json:"status"`
	// Active status of the zone
	Active             models.ActiveStatus `json:"active"`
	DefaultCode        types.NullableJSON  `json:"defaultCode"`
	Context            types.NullableJSON  `json:"context"`
	MinEcpm            float64             `json:"minECPM"`
	FixedPurchasePrice float64             `json:"fixedPurchasePrice"`
	AllowedFormats     []string            `json:"allowedFormats,omitempty"`
	AllowedTypes       []int64             `json:"allowedTypes,omitempty"`
	AllowedSources     []int64             `json:"allowedSources,omitempty"`
	DisallowedSources  []int64             `json:"disallowedSources,omitempty"`
	Campaigns          []int64             `json:"campaigns,omitempty"`
	CreatedAt          time.Time           `json:"createdAt"`
	UpdatedAt          time.Time           `json:"updatedAt"`
	DeletedAt          *time.Time          `json:"deletedAt,omitempty"`
}

// ZoneEdge wrapper to access Zone objects
type ZoneEdge struct {
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
	// The Zone at the end of ZoneEdge.
	Node *Zone `json:"node"`
}

// Input type for creating or updating a Zone.
type ZoneInput struct {
	// Account ID associated with the Zone. Must have appropriate permissions.
	AccountID *uint64 `json:"accountID,omitempty"`
	// Unique codename for the Zone.
	Codename *string `json:"codename,omitempty"`
	// Title of the Zone.
	Title *string `json:"title,omitempty"`
	// Description of the Zone.
	Description        *string     `json:"description,omitempty"`
	Type               *ZoneType   `json:"type,omitempty"`
	DefaultCode        *types.JSON `json:"defaultCode,omitempty"`
	Context            *types.JSON `json:"context,omitempty"`
	MinEcpm            *float64    `json:"minECPM,omitempty"`
	MinECPMByGeo       *types.JSON `json:"minECPMByGeo,omitempty"`
	FixedPurchasePrice *float64    `json:"fixedPurchasePrice,omitempty"`
	AllowedFormats     []string    `json:"allowedFormats,omitempty"`
	AllowedTypes       []int64     `json:"allowedTypes,omitempty"`
	AllowedSources     []int64     `json:"allowedSources,omitempty"`
	DisallowedSources  []int64     `json:"disallowedSources,omitempty"`
	Campaigns          []int64     `json:"campaigns,omitempty"`
}

// Filter input for listing Zones.
type ZoneListFilter struct {
	ID        []uint64              `json:"ID,omitempty"`
	Codename  []string              `json:"codename,omitempty"`
	AccountID []uint64              `json:"accountID,omitempty"`
	Type      *ZoneType             `json:"type,omitempty"`
	Status    *models.ApproveStatus `json:"status,omitempty"`
	Active    *models.ActiveStatus  `json:"active,omitempty"`
	MinEcpm   *float64              `json:"minECPM,omitempty"`
	MaxEcpm   *float64              `json:"maxECPM,omitempty"`
}

// Order input for listing Zones.
type ZoneListOrder struct {
	ID        *models.Ordering `json:"ID,omitempty"`
	Codename  *models.Ordering `json:"codename,omitempty"`
	Title     *models.Ordering `json:"title,omitempty"`
	AccountID *models.Ordering `json:"accountID,omitempty"`
	Type      *models.Ordering `json:"type,omitempty"`
	Status    *models.Ordering `json:"status,omitempty"`
	Active    *models.Ordering `json:"active,omitempty"`
	MinEcpm   *models.Ordering `json:"minECPM,omitempty"`
	CreatedAt *models.Ordering `json:"createdAt,omitempty"`
	UpdatedAt *models.Ordering `json:"updatedAt,omitempty"`
}

// ZonePayload wrapper to access Zone operation results
type ZonePayload struct {
	// A unique identifier for the client performing the mutation.
	ClientMutationID string `json:"clientMutationID"`
	// The Zone that was created or updated by this mutation.
	ZoneID uint64 `json:"zoneID"`
	// The Zone object accessible by a client.
	Zone *Zone `json:"zone"`
}

type AnyIPv4IPv6 string

const (
	AnyIPv4IPv6Any  AnyIPv4IPv6 = "ANY"
	AnyIPv4IPv6IPv4 AnyIPv4IPv6 = "IPv4"
	AnyIPv4IPv6IPv6 AnyIPv4IPv6 = "IPv6"
)

var AllAnyIPv4IPv6 = []AnyIPv4IPv6{
	AnyIPv4IPv6Any,
	AnyIPv4IPv6IPv4,
	AnyIPv4IPv6IPv6,
}

func (e AnyIPv4IPv6) IsValid() bool {
	switch e {
	case AnyIPv4IPv6Any, AnyIPv4IPv6IPv4, AnyIPv4IPv6IPv6:
		return true
	}
	return false
}

func (e AnyIPv4IPv6) String() string {
	return string(e)
}

func (e *AnyIPv4IPv6) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnyIPv4IPv6(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnyIPv4IPv6", str)
	}
	return nil
}

func (e AnyIPv4IPv6) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AnyOnlyExclude string

const (
	AnyOnlyExcludeAny     AnyOnlyExclude = "ANY"
	AnyOnlyExcludeOnly    AnyOnlyExclude = "ONLY"
	AnyOnlyExcludeExclude AnyOnlyExclude = "EXCLUDE"
)

var AllAnyOnlyExclude = []AnyOnlyExclude{
	AnyOnlyExcludeAny,
	AnyOnlyExcludeOnly,
	AnyOnlyExcludeExclude,
}

func (e AnyOnlyExclude) IsValid() bool {
	switch e {
	case AnyOnlyExcludeAny, AnyOnlyExcludeOnly, AnyOnlyExcludeExclude:
		return true
	}
	return false
}

func (e AnyOnlyExclude) String() string {
	return string(e)
}

func (e *AnyOnlyExclude) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnyOnlyExclude(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnyOnlyExclude", str)
	}
	return nil
}

func (e AnyOnlyExclude) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ApplicationType string

const (
	ApplicationTypeUndefined ApplicationType = "UNDEFINED"
	ApplicationTypeSite      ApplicationType = "SITE"
	ApplicationTypeApp       ApplicationType = "APP"
	ApplicationTypeGame      ApplicationType = "GAME"
)

var AllApplicationType = []ApplicationType{
	ApplicationTypeUndefined,
	ApplicationTypeSite,
	ApplicationTypeApp,
	ApplicationTypeGame,
}

func (e ApplicationType) IsValid() bool {
	switch e {
	case ApplicationTypeUndefined, ApplicationTypeSite, ApplicationTypeApp, ApplicationTypeGame:
		return true
	}
	return false
}

func (e ApplicationType) String() string {
	return string(e)
}

func (e *ApplicationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ApplicationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApplicationType", str)
	}
	return nil
}

func (e ApplicationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AuctionType string

const (
	AuctionTypeUndefined   AuctionType = "UNDEFINED"
	AuctionTypeFirstPrice  AuctionType = "FIRST_PRICE"
	AuctionTypeSecondPrice AuctionType = "SECOND_PRICE"
)

var AllAuctionType = []AuctionType{
	AuctionTypeUndefined,
	AuctionTypeFirstPrice,
	AuctionTypeSecondPrice,
}

func (e AuctionType) IsValid() bool {
	switch e {
	case AuctionTypeUndefined, AuctionTypeFirstPrice, AuctionTypeSecondPrice:
		return true
	}
	return false
}

func (e AuctionType) String() string {
	return string(e)
}

func (e *AuctionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuctionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuctionType", str)
	}
	return nil
}

func (e AuctionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PlatformType string

const (
	PlatformTypeUndefined      PlatformType = "UNDEFINED"
	PlatformTypeWeb            PlatformType = "WEB"
	PlatformTypeDesktop        PlatformType = "DESKTOP"
	PlatformTypeMobile         PlatformType = "MOBILE"
	PlatformTypeSmartPhone     PlatformType = "SMART_PHONE"
	PlatformTypeTablet         PlatformType = "TABLET"
	PlatformTypeSmartTv        PlatformType = "SMART_TV"
	PlatformTypeGameStation    PlatformType = "GAME_STATION"
	PlatformTypeSmartWatch     PlatformType = "SMART_WATCH"
	PlatformTypeVr             PlatformType = "VR"
	PlatformTypeSmartGlasses   PlatformType = "SMART_GLASSES"
	PlatformTypeSmartBillboard PlatformType = "SMART_BILLBOARD"
)

var AllPlatformType = []PlatformType{
	PlatformTypeUndefined,
	PlatformTypeWeb,
	PlatformTypeDesktop,
	PlatformTypeMobile,
	PlatformTypeSmartPhone,
	PlatformTypeTablet,
	PlatformTypeSmartTv,
	PlatformTypeGameStation,
	PlatformTypeSmartWatch,
	PlatformTypeVr,
	PlatformTypeSmartGlasses,
	PlatformTypeSmartBillboard,
}

func (e PlatformType) IsValid() bool {
	switch e {
	case PlatformTypeUndefined, PlatformTypeWeb, PlatformTypeDesktop, PlatformTypeMobile, PlatformTypeSmartPhone, PlatformTypeTablet, PlatformTypeSmartTv, PlatformTypeGameStation, PlatformTypeSmartWatch, PlatformTypeVr, PlatformTypeSmartGlasses, PlatformTypeSmartBillboard:
		return true
	}
	return false
}

func (e PlatformType) String() string {
	return string(e)
}

func (e *PlatformType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlatformType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlatformType", str)
	}
	return nil
}

func (e PlatformType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PricingModel string

const (
	PricingModelUndefined PricingModel = "UNDEFINED"
	PricingModelCpm       PricingModel = "CPM"
	PricingModelCpc       PricingModel = "CPC"
	PricingModelCpa       PricingModel = "CPA"
)

var AllPricingModel = []PricingModel{
	PricingModelUndefined,
	PricingModelCpm,
	PricingModelCpc,
	PricingModelCpa,
}

func (e PricingModel) IsValid() bool {
	switch e {
	case PricingModelUndefined, PricingModelCpm, PricingModelCpc, PricingModelCpa:
		return true
	}
	return false
}

func (e PricingModel) String() string {
	return string(e)
}

func (e *PricingModel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PricingModel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PricingModel", str)
	}
	return nil
}

func (e PricingModel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PrivateStatus string

const (
	PrivateStatusPublic  PrivateStatus = "PUBLIC"
	PrivateStatusPrivate PrivateStatus = "PRIVATE"
)

var AllPrivateStatus = []PrivateStatus{
	PrivateStatusPublic,
	PrivateStatusPrivate,
}

func (e PrivateStatus) IsValid() bool {
	switch e {
	case PrivateStatusPublic, PrivateStatusPrivate:
		return true
	}
	return false
}

func (e PrivateStatus) String() string {
	return string(e)
}

func (e *PrivateStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PrivateStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PrivateStatus", str)
	}
	return nil
}

func (e PrivateStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RTBRequestFormatType string

const (
	RTBRequestFormatTypeUndefined RTBRequestFormatType = "UNDEFINED"
	RTBRequestFormatTypeJSON      RTBRequestFormatType = "JSON"
	RTBRequestFormatTypeXML       RTBRequestFormatType = "XML"
)

var AllRTBRequestFormatType = []RTBRequestFormatType{
	RTBRequestFormatTypeUndefined,
	RTBRequestFormatTypeJSON,
	RTBRequestFormatTypeXML,
}

func (e RTBRequestFormatType) IsValid() bool {
	switch e {
	case RTBRequestFormatTypeUndefined, RTBRequestFormatTypeJSON, RTBRequestFormatTypeXML:
		return true
	}
	return false
}

func (e RTBRequestFormatType) String() string {
	return string(e)
}

func (e *RTBRequestFormatType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RTBRequestFormatType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RTBRequestFormatType", str)
	}
	return nil
}

func (e RTBRequestFormatType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StatisticCondition string

const (
	StatisticConditionEq StatisticCondition = "EQ"
	StatisticConditionNe StatisticCondition = "NE"
	StatisticConditionGt StatisticCondition = "GT"
	StatisticConditionGe StatisticCondition = "GE"
	StatisticConditionLt StatisticCondition = "LT"
	StatisticConditionLe StatisticCondition = "LE"
	StatisticConditionIn StatisticCondition = "IN"
	StatisticConditionNi StatisticCondition = "NI"
	StatisticConditionBt StatisticCondition = "BT"
	StatisticConditionNb StatisticCondition = "NB"
	StatisticConditionLi StatisticCondition = "LI"
	StatisticConditionNl StatisticCondition = "NL"
)

var AllStatisticCondition = []StatisticCondition{
	StatisticConditionEq,
	StatisticConditionNe,
	StatisticConditionGt,
	StatisticConditionGe,
	StatisticConditionLt,
	StatisticConditionLe,
	StatisticConditionIn,
	StatisticConditionNi,
	StatisticConditionBt,
	StatisticConditionNb,
	StatisticConditionLi,
	StatisticConditionNl,
}

func (e StatisticCondition) IsValid() bool {
	switch e {
	case StatisticConditionEq, StatisticConditionNe, StatisticConditionGt, StatisticConditionGe, StatisticConditionLt, StatisticConditionLe, StatisticConditionIn, StatisticConditionNi, StatisticConditionBt, StatisticConditionNb, StatisticConditionLi, StatisticConditionNl:
		return true
	}
	return false
}

func (e StatisticCondition) String() string {
	return string(e)
}

func (e *StatisticCondition) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StatisticCondition(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StatisticCondition", str)
	}
	return nil
}

func (e StatisticCondition) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StatisticKey string

const (
	StatisticKeyUndefined     StatisticKey = "UNDEFINED"
	StatisticKeyDatemark      StatisticKey = "DATEMARK"
	StatisticKeyTimemark      StatisticKey = "TIMEMARK"
	StatisticKeyCluster       StatisticKey = "CLUSTER"
	StatisticKeyProjectID     StatisticKey = "PROJECT_ID"
	StatisticKeyAccountID     StatisticKey = "ACCOUNT_ID"
	StatisticKeyPubAccountID  StatisticKey = "PUB_ACCOUNT_ID"
	StatisticKeyAdvAccountID  StatisticKey = "ADV_ACCOUNT_ID"
	StatisticKeySourceID      StatisticKey = "SOURCE_ID"
	StatisticKeyAccessPointID StatisticKey = "ACCESS_POINT_ID"
	StatisticKeyPlatform      StatisticKey = "PLATFORM"
	StatisticKeyDomain        StatisticKey = "DOMAIN"
	StatisticKeyAppID         StatisticKey = "APP_ID"
	StatisticKeyZoneID        StatisticKey = "ZONE_ID"
	StatisticKeyCampaignID    StatisticKey = "CAMPAIGN_ID"
	StatisticKeyAdID          StatisticKey = "AD_ID"
	StatisticKeyFormatID      StatisticKey = "FORMAT_ID"
	StatisticKeyJumperID      StatisticKey = "JUMPER_ID"
	StatisticKeyCarrierID     StatisticKey = "CARRIER_ID"
	StatisticKeyCountry       StatisticKey = "COUNTRY"
	StatisticKeyCity          StatisticKey = "CITY"
	StatisticKeyLanguage      StatisticKey = "LANGUAGE"
	StatisticKeyIP            StatisticKey = "IP"
	StatisticKeyDeviceType    StatisticKey = "DEVICE_TYPE"
	StatisticKeyDeviceID      StatisticKey = "DEVICE_ID"
	StatisticKeyOsID          StatisticKey = "OS_ID"
	StatisticKeyBrowserID     StatisticKey = "BROWSER_ID"
)

var AllStatisticKey = []StatisticKey{
	StatisticKeyUndefined,
	StatisticKeyDatemark,
	StatisticKeyTimemark,
	StatisticKeyCluster,
	StatisticKeyProjectID,
	StatisticKeyAccountID,
	StatisticKeyPubAccountID,
	StatisticKeyAdvAccountID,
	StatisticKeySourceID,
	StatisticKeyAccessPointID,
	StatisticKeyPlatform,
	StatisticKeyDomain,
	StatisticKeyAppID,
	StatisticKeyZoneID,
	StatisticKeyCampaignID,
	StatisticKeyAdID,
	StatisticKeyFormatID,
	StatisticKeyJumperID,
	StatisticKeyCarrierID,
	StatisticKeyCountry,
	StatisticKeyCity,
	StatisticKeyLanguage,
	StatisticKeyIP,
	StatisticKeyDeviceType,
	StatisticKeyDeviceID,
	StatisticKeyOsID,
	StatisticKeyBrowserID,
}

func (e StatisticKey) IsValid() bool {
	switch e {
	case StatisticKeyUndefined, StatisticKeyDatemark, StatisticKeyTimemark, StatisticKeyCluster, StatisticKeyProjectID, StatisticKeyAccountID, StatisticKeyPubAccountID, StatisticKeyAdvAccountID, StatisticKeySourceID, StatisticKeyAccessPointID, StatisticKeyPlatform, StatisticKeyDomain, StatisticKeyAppID, StatisticKeyZoneID, StatisticKeyCampaignID, StatisticKeyAdID, StatisticKeyFormatID, StatisticKeyJumperID, StatisticKeyCarrierID, StatisticKeyCountry, StatisticKeyCity, StatisticKeyLanguage, StatisticKeyIP, StatisticKeyDeviceType, StatisticKeyDeviceID, StatisticKeyOsID, StatisticKeyBrowserID:
		return true
	}
	return false
}

func (e StatisticKey) String() string {
	return string(e)
}

func (e *StatisticKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StatisticKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StatisticKey", str)
	}
	return nil
}

func (e StatisticKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StatisticOrderingKey string

const (
	StatisticOrderingKeyUndefined     StatisticOrderingKey = "UNDEFINED"
	StatisticOrderingKeyDatemark      StatisticOrderingKey = "DATEMARK"
	StatisticOrderingKeyTimemark      StatisticOrderingKey = "TIMEMARK"
	StatisticOrderingKeyCluster       StatisticOrderingKey = "CLUSTER"
	StatisticOrderingKeyProjectID     StatisticOrderingKey = "PROJECT_ID"
	StatisticOrderingKeyPubAccountID  StatisticOrderingKey = "PUB_ACCOUNT_ID"
	StatisticOrderingKeyAdvAccountID  StatisticOrderingKey = "ADV_ACCOUNT_ID"
	StatisticOrderingKeySourceID      StatisticOrderingKey = "SOURCE_ID"
	StatisticOrderingKeyAccessPointID StatisticOrderingKey = "ACCESS_POINT_ID"
	StatisticOrderingKeyPlatform      StatisticOrderingKey = "PLATFORM"
	StatisticOrderingKeyDomain        StatisticOrderingKey = "DOMAIN"
	StatisticOrderingKeyAppID         StatisticOrderingKey = "APP_ID"
	StatisticOrderingKeyZoneID        StatisticOrderingKey = "ZONE_ID"
	StatisticOrderingKeyCampaignID    StatisticOrderingKey = "CAMPAIGN_ID"
	StatisticOrderingKeyAdID          StatisticOrderingKey = "AD_ID"
	StatisticOrderingKeyFormatID      StatisticOrderingKey = "FORMAT_ID"
	StatisticOrderingKeyJumperID      StatisticOrderingKey = "JUMPER_ID"
	StatisticOrderingKeyCarrierID     StatisticOrderingKey = "CARRIER_ID"
	StatisticOrderingKeyCountry       StatisticOrderingKey = "COUNTRY"
	StatisticOrderingKeyCity          StatisticOrderingKey = "CITY"
	StatisticOrderingKeyLanguage      StatisticOrderingKey = "LANGUAGE"
	StatisticOrderingKeyIP            StatisticOrderingKey = "IP"
	StatisticOrderingKeyDeviceType    StatisticOrderingKey = "DEVICE_TYPE"
	StatisticOrderingKeyDeviceID      StatisticOrderingKey = "DEVICE_ID"
	StatisticOrderingKeyOsID          StatisticOrderingKey = "OS_ID"
	StatisticOrderingKeyBrowserID     StatisticOrderingKey = "BROWSER_ID"
	StatisticOrderingKeySpent         StatisticOrderingKey = "SPENT"
	StatisticOrderingKeyProfit        StatisticOrderingKey = "PROFIT"
	StatisticOrderingKeyBidPrice      StatisticOrderingKey = "BID_PRICE"
	StatisticOrderingKeyRequests      StatisticOrderingKey = "REQUESTS"
	StatisticOrderingKeyImpressions   StatisticOrderingKey = "IMPRESSIONS"
	StatisticOrderingKeyViews         StatisticOrderingKey = "VIEWS"
	StatisticOrderingKeyDirects       StatisticOrderingKey = "DIRECTS"
	StatisticOrderingKeyClicks        StatisticOrderingKey = "CLICKS"
	StatisticOrderingKeyLeads         StatisticOrderingKey = "LEADS"
	StatisticOrderingKeyBids          StatisticOrderingKey = "BIDS"
	StatisticOrderingKeyWins          StatisticOrderingKey = "WINS"
	StatisticOrderingKeySkips         StatisticOrderingKey = "SKIPS"
	StatisticOrderingKeyNobids        StatisticOrderingKey = "NOBIDS"
	StatisticOrderingKeyErrors        StatisticOrderingKey = "ERRORS"
	StatisticOrderingKeyCtr           StatisticOrderingKey = "CTR"
	StatisticOrderingKeyEcpm          StatisticOrderingKey = "ECPM"
	StatisticOrderingKeyEcpc          StatisticOrderingKey = "ECPC"
	StatisticOrderingKeyEcpa          StatisticOrderingKey = "ECPA"
)

var AllStatisticOrderingKey = []StatisticOrderingKey{
	StatisticOrderingKeyUndefined,
	StatisticOrderingKeyDatemark,
	StatisticOrderingKeyTimemark,
	StatisticOrderingKeyCluster,
	StatisticOrderingKeyProjectID,
	StatisticOrderingKeyPubAccountID,
	StatisticOrderingKeyAdvAccountID,
	StatisticOrderingKeySourceID,
	StatisticOrderingKeyAccessPointID,
	StatisticOrderingKeyPlatform,
	StatisticOrderingKeyDomain,
	StatisticOrderingKeyAppID,
	StatisticOrderingKeyZoneID,
	StatisticOrderingKeyCampaignID,
	StatisticOrderingKeyAdID,
	StatisticOrderingKeyFormatID,
	StatisticOrderingKeyJumperID,
	StatisticOrderingKeyCarrierID,
	StatisticOrderingKeyCountry,
	StatisticOrderingKeyCity,
	StatisticOrderingKeyLanguage,
	StatisticOrderingKeyIP,
	StatisticOrderingKeyDeviceType,
	StatisticOrderingKeyDeviceID,
	StatisticOrderingKeyOsID,
	StatisticOrderingKeyBrowserID,
	StatisticOrderingKeySpent,
	StatisticOrderingKeyProfit,
	StatisticOrderingKeyBidPrice,
	StatisticOrderingKeyRequests,
	StatisticOrderingKeyImpressions,
	StatisticOrderingKeyViews,
	StatisticOrderingKeyDirects,
	StatisticOrderingKeyClicks,
	StatisticOrderingKeyLeads,
	StatisticOrderingKeyBids,
	StatisticOrderingKeyWins,
	StatisticOrderingKeySkips,
	StatisticOrderingKeyNobids,
	StatisticOrderingKeyErrors,
	StatisticOrderingKeyCtr,
	StatisticOrderingKeyEcpm,
	StatisticOrderingKeyEcpc,
	StatisticOrderingKeyEcpa,
}

func (e StatisticOrderingKey) IsValid() bool {
	switch e {
	case StatisticOrderingKeyUndefined, StatisticOrderingKeyDatemark, StatisticOrderingKeyTimemark, StatisticOrderingKeyCluster, StatisticOrderingKeyProjectID, StatisticOrderingKeyPubAccountID, StatisticOrderingKeyAdvAccountID, StatisticOrderingKeySourceID, StatisticOrderingKeyAccessPointID, StatisticOrderingKeyPlatform, StatisticOrderingKeyDomain, StatisticOrderingKeyAppID, StatisticOrderingKeyZoneID, StatisticOrderingKeyCampaignID, StatisticOrderingKeyAdID, StatisticOrderingKeyFormatID, StatisticOrderingKeyJumperID, StatisticOrderingKeyCarrierID, StatisticOrderingKeyCountry, StatisticOrderingKeyCity, StatisticOrderingKeyLanguage, StatisticOrderingKeyIP, StatisticOrderingKeyDeviceType, StatisticOrderingKeyDeviceID, StatisticOrderingKeyOsID, StatisticOrderingKeyBrowserID, StatisticOrderingKeySpent, StatisticOrderingKeyProfit, StatisticOrderingKeyBidPrice, StatisticOrderingKeyRequests, StatisticOrderingKeyImpressions, StatisticOrderingKeyViews, StatisticOrderingKeyDirects, StatisticOrderingKeyClicks, StatisticOrderingKeyLeads, StatisticOrderingKeyBids, StatisticOrderingKeyWins, StatisticOrderingKeySkips, StatisticOrderingKeyNobids, StatisticOrderingKeyErrors, StatisticOrderingKeyCtr, StatisticOrderingKeyEcpm, StatisticOrderingKeyEcpc, StatisticOrderingKeyEcpa:
		return true
	}
	return false
}

func (e StatisticOrderingKey) String() string {
	return string(e)
}

func (e *StatisticOrderingKey) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StatisticOrderingKey(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StatisticOrderingKey", str)
	}
	return nil
}

func (e StatisticOrderingKey) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Enumeration of possible Zone types.
type ZoneType string

const (
	ZoneTypeDefault   ZoneType = "DEFAULT"
	ZoneTypeSmartLink ZoneType = "SMART_LINK"
)

var AllZoneType = []ZoneType{
	ZoneTypeDefault,
	ZoneTypeSmartLink,
}

func (e ZoneType) IsValid() bool {
	switch e {
	case ZoneTypeDefault, ZoneTypeSmartLink:
		return true
	}
	return false
}

func (e ZoneType) String() string {
	return string(e)
}

func (e *ZoneType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ZoneType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ZoneType", str)
	}
	return nil
}

func (e ZoneType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
